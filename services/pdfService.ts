import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import type { jsPDF as jsPDFType } from 'jspdf';
import type { Core, Section, Microfossil, Folder } from '../types';
import { PROXY_LABELS, ODV_PROXY_LABELS } from '../constants';

// Constants for layout
const TOP_MARGIN = 30;
const BOTTOM_MARGIN = 20;
const LEFT_MARGIN = 14;

// Draws header on the CURRENT page. This is a modular building block.
const addHeader = (doc: jsPDFType, title: string, userEmail: string, creationDate: string) => {
    const pageWidth = doc.internal.pageSize.getWidth();
    
    doc.setFontSize(14);
    doc.setFont('helvetica', 'bold');
    doc.text(title, pageWidth / 2, 15, { align: 'center' });
    
    doc.setFontSize(8);
    doc.setFont('helvetica', 'normal');
    doc.text(`Generated by: ${userEmail}`, LEFT_MARGIN, 22);
    doc.text(`Created on: ${new Date(creationDate).toLocaleDateString()}`, pageWidth - LEFT_MARGIN, 22, { align: 'right' });

    doc.setDrawColor(150, 150, 150);
    doc.line(LEFT_MARGIN, 25, pageWidth - LEFT_MARGIN, 25);
};

// Draws footers on ALL pages at the end.
const addFooters = (doc: jsPDFType) => {
    const pageCount = (doc.internal as any).getNumberOfPages();
    const pageHeight = doc.internal.pageSize.getHeight();

    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.getWidth() / 2, pageHeight - 10, { align: 'center' });
    }
};

// This function draws the content of a single section, managing pagination correctly.
const generateSectionContent = (doc: jsPDFType, section: Section, microfossils: Microfossil[], userEmail: string, sectionTitle: string) => {
    let y = TOP_MARGIN;
    const creationDate = section.createdAt || new Date().toISOString();
    const pageWidth = doc.internal.pageSize.getWidth();
    const contentWidth = pageWidth - (LEFT_MARGIN * 2);

    const checkAndAddPage = (requiredHeight = 20) => {
        if (y + requiredHeight > doc.internal.pageSize.getHeight() - BOTTOM_MARGIN) {
            doc.addPage();
            addHeader(doc, sectionTitle, userEmail, creationDate);
            y = TOP_MARGIN;
        }
    };

    const addSectionBlock = (title: string, bodyFunc: () => void) => {
        checkAndAddPage(15); // Check space for header
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text(title, LEFT_MARGIN, y);
        y += 2;
        doc.setDrawColor(74, 144, 226); // accent color
        doc.line(LEFT_MARGIN, y, pageWidth - LEFT_MARGIN, y);
        y += 8;
        bodyFunc();
    };

    const addTable = (head: any[][], body: any[][], columnStyles?: any) => {
        autoTable(doc, {
            startY: y,
            head: head,
            body: body,
            theme: 'striped',
            headStyles: { fillColor: [74, 144, 226] },
            styles: { fontSize: 8, cellPadding: 1.5, overflow: 'linebreak' },
            columnStyles: columnStyles || { 0: { fontStyle: 'bold', cellWidth: 'auto' } },
            margin: { top: TOP_MARGIN, bottom: BOTTOM_MARGIN, left: LEFT_MARGIN, right: LEFT_MARGIN },
            didDrawPage: (data) => {
                // Add header to each new page created by the table
                addHeader(doc, sectionTitle, userEmail, creationDate);
            },
        });
        y = (doc as any).lastAutoTable.finalY + 10;
    };

    // --- Content Blocks ---

    addSectionBlock('Section & Recovery Details', () => {
        addTable([], [
            ['Collector', section.collector || 'N/A'], ['Recovery Date', section.recoveryDate],
            ['Section Depth', section.sectionDepth ? `${section.sectionDepth} cmbsf` : 'N/A'],
            ['Sample Interval', section.sampleInterval ? `${section.sampleInterval} cm` : 'N/A'],
        ]);
    });
    
    addSectionBlock('Geological Context', () => {
        addTable([], [
            ['Epoch', section.epoch], ['Climatic Period', section.geologicalPeriod],
            ['Age Range', section.ageRange],
            ['Paleomagnetic Reversals', section.paleomagneticReversals || 'N/A'],
        ]);
    });
    
    addSectionBlock('Lithology', () => {
        addTable([], [
            ['Primary Lithology', section.lithology || 'N/A'], ['Munsell Color', section.munsellColor || 'N/A'],
            ['Grain Size', section.grainSize || 'N/A'], ['Tephra Layers', section.tephraLayers || 'N/A'],
        ]);
    });

    addSectionBlock('Microfossil Assemblage', () => {
        if (section.microfossilRecords.length > 0) {
            const fossilBody = section.microfossilRecords.map(record => {
                const fossil = microfossils.find(f => f.id === record.fossilId);
                return [fossil ? `${fossil.taxonomy.genus} ${fossil.taxonomy.species}` : record.fossilId, record.abundance, record.preservation, record.observations || 'N/A'];
            });
            addTable([['Species', 'Abundance', 'Preservation', 'Observations']], fossilBody);
        } else {
            checkAndAddPage();
            doc.setFontSize(9).setFont('helvetica', 'italic').text('No microfossil records.', LEFT_MARGIN, y);
            y += 10;
        }
    });

    addSectionBlock('Raw Data Series (Subsections)', () => {
        if (section.dataPoints && section.dataPoints.length > 0) {
            const allHeaders = new Set<string>();
            section.dataPoints.forEach(dp => Object.keys(dp).forEach(key => allHeaders.add(key)));

            const headerArray = Array.from(allHeaders);
            const subsectionIndex = headerArray.findIndex(h => h.toLowerCase() === 'subsection');
            let orderedHeaders: string[];
            if (subsectionIndex > -1) {
                const subsectionHeader = headerArray[subsectionIndex];
                orderedHeaders = [subsectionHeader, ...headerArray.filter(h => h !== subsectionHeader)];
            } else {
                orderedHeaders = headerArray;
            }

            const head = [orderedHeaders.map(h => PROXY_LABELS[h] || h.toUpperCase())];
            const body = section.dataPoints.map(dp => 
                orderedHeaders.map(header => {
                    const value = dp[header];
                    if (value === null || value === undefined) return '-';
                    if (typeof value === 'number') return value.toFixed(4);
                    return String(value);
                })
            );

            // For a wide table, we don't want the first column to be extra wide.
            const columnStyles = orderedHeaders.reduce((acc, header, index) => {
                acc[index] = { cellWidth: 'auto' };
                return acc;
            }, {} as any);
            
            addTable(head, body, columnStyles);

        } else {
            checkAndAddPage();
            doc.setFontSize(9).setFont('helvetica', 'italic').text('No data series available for this section.', LEFT_MARGIN, y);
            y += 10;
        }
    });

    if (section.summary) {
        addSectionBlock('AI-Generated Scientific Summary', () => {
            doc.setFontSize(10);
            doc.setFont('helvetica', 'normal');
            const splitSummary = doc.splitTextToSize(section.summary, contentWidth);
            checkAndAddPage(splitSummary.length * 5); // Rough height check
            doc.text(splitSummary, LEFT_MARGIN, y);
            y += (splitSummary.length * 5) + 10;
        });
    }
};

export const generateSectionReport = (section: Section, microfossils: Microfossil[], userEmail: string) => {
    const doc = new jsPDF('p', 'mm', 'a4');
    const title = `Section Report: ${section.name}`;
    const creationDate = section.createdAt || new Date().toISOString();
    
    addHeader(doc, title, userEmail, creationDate);
    generateSectionContent(doc, section, microfossils, userEmail, title);
    
    addFooters(doc);
    doc.save(`${section.core_id}_${section.name}_Report.pdf`);
};

export const generateFullCoreReport = (core: Core, sections: Section[], microfossils: Microfossil[], userEmail: string, synthesisChartData: { dataUrl: string; aspectRatio: number } | null = null) => {
    const doc = new jsPDF('p', 'mm', 'a4');
    
    // Title Page
    doc.setFontSize(28).setFont('helvetica', 'bold').text('Full Core Report', 105, 120, { align: 'center' });
    doc.setFontSize(22).setFont('helvetica', 'normal').text(core.id, 105, 140, { align: 'center' });
    doc.setFontSize(16).setTextColor(100).text(core.name, 105, 150, { align: 'center' });
    autoTable(doc, {
        startY: 170,
        body: [['Project', core.project], ['Location', `${core.location.lat.toFixed(4)}°, ${core.location.lon.toFixed(4)}°`], ['Water Depth', `${core.waterDepth} m`]],
        theme: 'plain', styles: { fontSize: 12, cellPadding: 3 }, columnStyles: { 0: { fontStyle: 'bold' } }, margin: { left: 50 }
    });
    
    // Add sections
    sections.forEach(section => {
        doc.addPage();
        const sectionTitle = `Report for Core: ${core.id} / Section: ${section.name}`;
        const creationDate = section.createdAt || new Date().toISOString();
        addHeader(doc, sectionTitle, userEmail, creationDate);
        generateSectionContent(doc, section, microfossils, userEmail, sectionTitle);
    });
    
    // Add Synthesis Chart Page if it exists
    if (synthesisChartData) {
        doc.addPage();
        const chartTitle = `Core Synthesis Chart`;
        const creationDate = new Date().toISOString();
        addHeader(doc, chartTitle, userEmail, creationDate);

        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const contentWidth = pageWidth - (LEFT_MARGIN * 2);
        
        const aspectRatio = synthesisChartData.aspectRatio;

        let finalImgWidth = contentWidth;
        let finalImgHeight = finalImgWidth / aspectRatio;

        const availableHeight = pageHeight - TOP_MARGIN - BOTTOM_MARGIN - 20; // Extra margin for header and padding
        if (finalImgHeight > availableHeight) {
            finalImgHeight = availableHeight;
            finalImgWidth = finalImgHeight * aspectRatio;
        }

        const x = (pageWidth - finalImgWidth) / 2;
        const y = TOP_MARGIN + 10; // Extra margin below header

        doc.addImage(synthesisChartData.dataUrl, 'PNG', x, y, finalImgWidth, finalImgHeight);
    }


    // Add footers to all pages at the end (including title page initially)
    addFooters(doc);
    
    // Remove footer from title page as it has no header
    doc.setPage(1);
    doc.setFillColor(255, 255, 255);
    doc.rect(0, doc.internal.pageSize.getHeight() - BOTTOM_MARGIN, doc.internal.pageSize.getWidth(), BOTTOM_MARGIN, 'F');
    
    doc.save(`${core.id}_Full_Report.pdf`);
};

export const exportFolderToOdv = (folder: Folder, cores: Core[], allSections: Section[]) => {
    if (allSections.length === 0 || allSections.every(s => s.dataPoints.length === 0)) {
        // The calling function should handle toast for this case.
        throw new Error("No data points found in any section within this folder.");
    }
    
    const delimiter = ';';

    // Collect all headers from all data points across all sections
    const allPossibleHeaders = new Set<string>();
    allSections.forEach(section => {
        section.dataPoints.forEach(dp => {
            Object.keys(dp).forEach(key => allPossibleHeaders.add(key));
        });
    });

    const priority = ['subsection', 'depth', 'age'];
    const dataPointHeaders = [
      ...priority.filter(p => allPossibleHeaders.has(p)),
      ...Array.from(allPossibleHeaders).filter(key => !priority.includes(key) && key !== '$$typeof' && key !== '_owner') // Filter out React internals if they sneak in
    ];

    const staticHeaders = ['Cruise', 'Station', 'Type', 'Longitude', 'Latitude', 'Water_Depth [m]'];
    const dynamicHeaders = dataPointHeaders.map(key => ODV_PROXY_LABELS[key] || key);
    const allHeaders = [...staticHeaders, ...dynamicHeaders];

    let odvContent = `// Source File: PaleoCore Analyst Export (Optimized for ODV)\n`;
    odvContent += `// Project: ${folder.name}\n`;
    odvContent += `// Delimiter: Semicolon\n`;
    odvContent += `//---\n`;
    odvContent += allHeaders.join(delimiter) + '\n';

    // Create a map for quick core lookup
    const coreMap = new Map(cores.map(c => [c.id, c]));

    // Data Rows
    allSections.forEach(section => {
        const core = coreMap.get(section.core_id);
        if (!core) return; // Should not happen if data is consistent

        section.dataPoints.forEach(dp => {
            const staticValues = [
                core.project.replace(/;/g,','),
                core.id.replace(/;/g,','),
                'Core Section',
                core.location.lon,
                core.location.lat,
                core.waterDepth,
            ];

            const dynamicValues = dataPointHeaders.map(header => {
                const value = dp[header];
                return (value === null || value === undefined) ? '' : String(value).replace(/;/g,',');
            });
            
            const row = [...staticValues, ...dynamicValues];
            odvContent += row.join(delimiter) + '\n';
        });
    });

    // Download logic
    const blob = new Blob([odvContent], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `PaleoCore_Export_${folder.name.replace(/\s/g, '_')}.odv.txt`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
};